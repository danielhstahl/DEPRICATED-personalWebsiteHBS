var Complex=require('Complex'); //exportable class
var ode=function(options){

  function thomas(a, b, c, psi){ //a, b, c, psi are vectors, a is complex
    //if b.length=a.length or c.length=a.length, only first n-1 records are used
    var n=a.length;//get number of records on diagonal
    psi[0]=new Complex(psi[0], 0);
    for(var i=1; i<n; i++){ //forward loop
      var gamHat= new Complex(c[i-1], 0).divide(a[i-1]);
      a[i]=a[i].add(new Complex(-b[i-1], 0).multiply(gamHat)); //make sure that divide works...
      psi[i]=new Complex(psi[i], 0).subtract(psi[i-1].multiply(gamHat));

    }
    var phi=new Array(n+2); //the solution
    phi[n]=psi[n-1].divide(a[n-1]);
    phi[0]=0; //boundaries..MODIFIED THOMAS
    phi[n+1]=1;//boundaries..MODIFIED THOMAS

    //console.log(psi);
    for(var i=(n-2); i>-1; i--){ //backward loop
      phi[i+1]=psi[i].add(phi[i+2].multiply(new Complex(-b[i], 0))).divide(a[i]);
      //phi[i+1]=math.divide(math.add(psi[i], math.multiply(-b[i], phi[i+2])), a[i]);
      phi[i+2]=phi[i+2].real;
      //phi[i+2]=math.re(phi[i+2]); //only keep real part
    }
    //phi[1]=math.re(phi[1]); //only keep real part
    phi[1]=phi[1].real;
    return phi;
  }
  this.execute=function(u){
    var n=options.n;
    var m=options.m;
    var alpha=options.alpha;
    var delta=options.delta;
    var dx=m/(n-1); //the domain is [0, m] since a CEV process is always positive.
    var a=new Array(n-2);//first and last are boundary conditions
    var b=new Array(n-2);//first and last are boundary conditions
    var c=new Array(n-2);//first and last are boundary conditions
    var psi=new Array(n-2);//first and last are boundary conditions
    var sigs=(options.sigma*options.sigma)/(dx*dx);
    for(var i=0; i<(n-2); i++){ //first and last are boundary conditions
      //a[i]=math.subtract(math.complex(0, mu), math.pow(dx*(i+1), 2*delta)*sigs);
      a[i]=new Complex(0, u).subtract(new Complex(Math.pow(dx*(i+1), 2*delta)*sigs, 0));
      b[i]=Math.pow(dx*(i+1), 2*delta)*.5*sigs+.5*alpha*(i+1);
      c[i]=Math.pow(dx*(i+2), 2*delta)*.5*sigs-.5*alpha*(i+2); //note that x_{j+1} instead of x_j
      psi[i]=0;
    }
    psi[n-3]=-b[n-3]; //boundary condition
    var phi=thomas(a, b, c, psi); //solve equation
    return phi;
  }
}
module.exports=ode;
