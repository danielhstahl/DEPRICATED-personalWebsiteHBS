/*my ops risk model*/
"use strict";
var Complex = require('Complex'); //exportable class
var ode = require('rngOpsRisk'); //exportable class
var FangOosterlee = require('FangOosterlee'); //exportable class

process.on('message', function(options) {
  var a = options.a;
  //var c = options.c;
  //var d = options.d;
  var lambda = options.lambda;
  /*var delta = options.delta / (c * d * lambda);
  var v0 = options.v0;
  var cmplv0 = new Complex(v0, 0);
  var b = 1 - d * c * lambda * delta;
  var t = options.t;
  var sigma = options.sigma;
  var n = options.n;
  var l = options.l;
  var k = options.k;
  var deltaC = new Complex(-delta, 0);
  var lambdaC = new Complex(lambda, 0);
  var unity = new Complex(1, 0);
  var sigSq = new Complex(sigma * sigma * .5, 0);
  var cC = new Complex(-c, 0);
  var aC = new Complex(a, 0);
  var ab = new Complex(a * b, 0);*/
  var alphaStable=options.alphaStable;
  var betaStable=1; //hardcoded due to requirement that negative numbers be not very likely
  var cStable=options.cStable;
  var muStable=options.muStable;
  var delta = options.delta / (muStable * lambda);
  var v0 = options.v0;
  var cmplv0 = new Complex(v0, 0);
  var b = 1 - muStable * lambda * delta;
  var t = options.t;
  var sigma = options.sigma;
  var n = options.n;
  var l = options.l;
  var k = options.k;
  var deltaC = new Complex(delta, 0);
  var lambdaC = new Complex(lambda, 0);
  var unity = new Complex(1, 0);
  var sigSq = new Complex(sigma * sigma * .5, 0);
  var aC = new Complex(a, 0);
  var ab = new Complex(a * b, 0);
  var options = {
    n: n,
    initialY: [0, 0],
    initialX: 0,
    maxX: t,
    complex: true
  };
  function stableCF(u, alpha, beta, c, mu){ //for "base" cf, u is real not complex...this returns correct results
    if(!u.real && u.real!==0){ //isnt a complex number
      u=new Complex(u, 0);
    }
    var phi=Math.tan(Math.PI*alpha*.5);
    var toRet=u.multiply(new Complex(0, mu)).subtract(u.multiply(new Complex(c, 0)).power(alpha).multiply(new Complex(1, 0).subtract(new Complex(0, phi*beta)))).exp();
    return toRet;

  }

  var beta = function(bet, u) {
    //var chat = new Complex(c, 0).divide(u.multiply(cC).add(unity));
    //return u.multiply(cC).add(unity).multiply(bet.multiply(deltaC).multiply(chat).add(unity)).power(-d).multiply(lambdaC).subtract(lambdaC).subtract(bet.multiply(aC)).add(bet.multiply(bet).multiply(sigSq)); //gamma distribution
    var totalU=u.add(bet.multiply(deltaC)).multiply(new Complex(0, -1)); //this is correct..
    return stableCF(totalU, alphaStable, betaStable, cStable, muStable).multiply(lambdaC).add(bet.multiply(bet).multiply(sigSq)).subtract(lambdaC).subtract(bet.multiply(aC));
  }
  var alpha = function(bet) {
    return bet.multiply(ab);
  }
  //console.log(new Complex(.005, .005).multiply(new Complex(.005, .005)).multiply(sigSq));
  //console.log(stableCF(new Complex(.005, .005), alphaStable, betaStable, cStable, muStable).multiply(lambdaC));
  //console.log(beta(new Complex(.005, .005), new Complex(.005, .005)));
  //console.log(new Complex(.005, .005).add(new Complex(.005, .005).multiply(deltaC)).multiply(new Complex(0, -1)));
  //console.log(new Complex(.005, .005).add(new Complex(.005, .005).multiply(deltaC)));
//  console.log(new Complex(.005, .005).multiply(deltaC));
  var chrFunc = {
    execute: function(u) {

      var zeroy=new Complex(0, 0);
      var rngBeta=ode(function(x){return beta(x, u);}, alpha, zeroy, zeroy, options);
      return rngBeta[0][options.n].multiply(cmplv0).add(rngBeta[1][options.n]).exp();

    }

  }
  var computeDist = new FangOosterlee(l, k);
  var startTime = new Date();
  var res = computeDist.computeDistribution(chrFunc, -cStable*lambda*t, muStable*lambda*t+cStable*lambda*t*35);
  var endTime = new Date() - startTime;
  console.log(endTime / 1000);
  //var res = computeDist.computeDistribution(chrFunc, -1000, 3000);
  //var res = computeDist.computeDistribution(chrFunc, 0, d * c * lambda * t * 10); /*very rough...10 is arbitrary*/
  process.send({
    result: res
  });
  process.send({
    close: "close"
  });
});
